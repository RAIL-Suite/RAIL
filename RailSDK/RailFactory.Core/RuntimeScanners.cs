using System;
using System.Collections.Generic;
using System.Linq;
using dnlib.DotNet;

namespace RailFactory.Core;

/// <summary>
/// Enterprise-grade .NET assembly scanner using dnlib.
/// Supports all .NET versions (Framework, Core, 5-9) and all optional parameter scenarios.
/// Filters auto-generated methods and ensures unique method names in manifest.
/// JSON Schema expansion for complex types (Gemini-compatible).
/// </summary>
public class DotNetRuntimeScanner : IRuntimeScanner
{
    // Auto-generated methods to skip (WPF, WinForms, etc.)
    private static readonly HashSet<string> AutoGeneratedMethods = new()
    {
        "InitializeComponent",  // WPF/WinForms designer
        "Dispose",              // IDisposable (usually protected/private, but just in case)
        "GetType",              // System.Object
        "ToString",             // System.Object
        "Equals",               // System.Object
        "GetHashCode",          // System.Object
        "MemberwiseClone"       // System.Object
    };
    
    // Enterprise polyglot type mapping: .NET types â†’ JSON Schema types (Gemini-compatible)
    private static readonly Dictionary<string, string> JsonSchemaTypeMap = new()
    {
        // Integers
        { "System.Int16", "INTEGER" },
        { "System.Int32", "INTEGER" },
        { "System.Int64", "INTEGER" },
        { "System.UInt16", "INTEGER" },
        { "System.UInt32", "INTEGER" },
        { "System.UInt64", "INTEGER" },
        { "System.Byte", "INTEGER" },
        { "System.SByte", "INTEGER" },
        
        // Floating point
        { "System.Single", "NUMBER" },
        { "System.Double", "NUMBER" },
        { "System.Decimal", "NUMBER" },
        
        // Text
        { "System.String", "STRING" },
        { "System.Char", "STRING" },
        
        // Boolean
        { "System.Boolean", "BOOLEAN" },
        
        // Special
        { "System.Object", "OBJECT" },
        { "System.Void", "NULL" }
    };
    
    // C# display type names for UI (user-friendly)
    private static readonly Dictionary<string, string> CSharpDisplayTypeMap = new()
    {
        { "INTEGER", "int" },
        { "NUMBER", "double" },
        { "STRING", "string" },
        { "BOOLEAN", "bool" },
        { "ARRAY", "List" },
        { "OBJECT", "object" },
        { "NULL", "void" }
    };

    public List<RailMethod> ScanBinary(string filePath, RailFactory.Core.ScanOptions? options = null)
    {
        options ??= new RailFactory.Core.ScanOptions(); // Default if null
        
        var methods = new List<RailMethod>();
        var uniqueMethods = new HashSet<string>(); // Track unique method signatures
        
        try
        {
            using (var module = ModuleDefMD.Load(filePath))
            {
                foreach (var type in module.Types)
                {
                    // Only scan public classes
                    if (!type.IsPublic)
                        continue;
                    
                    // Skip compiler-generated types
                    if (options.ExcludeCompilerGenerated && 
                        (type.Name.Contains("<") || type.Name.Contains(">")))
                        continue;
                        
                    foreach (var method in type.Methods)
                    {
                        // Visibility checks
                        if (method.IsPublic && !options.IncludePublic) continue;
                        if (method.IsPrivate && !options.IncludePrivate) continue;
                        if (method.IsFamily && !options.IncludeProtected) continue;
                        if (method.IsAssembly && !options.IncludeInternal) continue;
                        
                        // Method type checks
                        if (method.IsStatic && !options.IncludeStatic) continue;
                        if (!method.IsStatic && !options.IncludeInstance) continue;
                            
                        // Skip constructors
                        if (method.IsConstructor && !options.IncludeConstructors)
                            continue;
                            
                        // Skip property getters/setters
                        if ((method.IsGetter || method.IsSetter) && !options.IncludeProperties)
                            continue;
                            
                        // Skip special names (operators, etc.)
                        if (method.IsSpecialName && !options.IncludeOperators)
                            continue;
                        
                        // Skip auto-generated methods
                        if (options.ExcludeSystemObjectMethods && AutoGeneratedMethods.Contains(method.Name))
                            continue;
                        
                        // Create unique signature: ClassName.MethodName(param types)
                        var signature = GetMethodSignature(type, method);
                        
                        // Skip duplicates (same method from multiple classes)
                        if (options.RemoveDuplicates && !uniqueMethods.Add(signature))
                            continue;
                            
                        methods.Add(new RailMethod
                        {
                            ClassName = type.FullName,
                            MethodName = method.Name,
                            Description = GetMethodDescription(method),
                            ReturnType = ConvertDnlibType(method.ReturnType),
                            Parameters = ExtractParameters(method)
                        });
                    }
                }
            }
        }
        catch (Exception ex)
        {
            // Log actual exception details for debugging
            var innerMsg = ex.InnerException?.Message ?? ex.Message;
            throw new InvalidOperationException(
                $"Failed to scan .NET assembly: {filePath}\nReason: {innerMsg}\nType: {ex.GetType().Name}", ex);
        }
        
        return methods;
    }
    
    /// <summary>
    /// Creates unique method signature for duplicate detection.
    /// Format: "ClassName.MethodName(Type1,Type2)"
    /// </summary>
    private string GetMethodSignature(TypeDef type, MethodDef method)
    {
        var paramTypes = string.Join(",", 
            method.Parameters
                .Where(p => !p.IsHiddenThisParameter)
                .Select(p => p.Type.FullName));
                
        return $"{type.FullName}.{method.Name}({paramTypes})";
    }
    
    /// <summary>
    /// Extracts parameters with comprehensive optional detection.
    /// </summary>
    private List<RailParameter> ExtractParameters(MethodDef method)
    {
        var parameters = new List<RailParameter>();
        
        int paramIndex = 0;
        foreach (var param in method.Parameters)
        {
            // Skip 'this' parameter
            if (param.IsHiddenThisParameter)
                continue;
            
            // Find corresponding ParamDef by sequence number
            var paramDef = method.ParamDefs.FirstOrDefault(pd => pd.Sequence == paramIndex + 1);
            
            parameters.Add(new RailParameter
            {
                Name = param.Name ?? paramDef?.Name ?? "arg",
                ParameterType = ConvertDnlibType(param.Type),
                IsOptional = paramDef != null && IsParameterOptional(paramDef),
                DefaultValue = paramDef != null ? GetDefaultValue(paramDef) : null
            });
            
            paramIndex++;
        }
        
        return parameters;
    }
    
    /// <summary>
    /// Enterprise-grade optional parameter detection.
    /// </summary>
    private bool IsParameterOptional(ParamDef paramDef)
    {
        // Case 1: C# default value literal
        if (paramDef.HasConstant)
            return true;
        
        // Case 2: VB.NET [Optional] attribute
        if (paramDef.CustomAttributes.Any(a => 
            a.TypeFullName == "System.Runtime.InteropServices.OptionalAttribute"))
            return true;
        
        // Case 3: DefaultParameterValueAttribute
        if (paramDef.CustomAttributes.Any(a => 
            a.TypeFullName == "System.Runtime.InteropServices.DefaultParameterValueAttribute"))
            return true;
        
        // Case 4: params array
        if (paramDef.CustomAttributes.Any(a => 
            a.TypeFullName == "System.ParamArrayAttribute"))
            return true;
            
        return false;
    }
    
    /// <summary>
    /// Extracts default value from parameter metadata.
    /// </summary>
    private object? GetDefaultValue(ParamDef paramDef)
    {
        // Case 1: Literal constant
        if (paramDef.HasConstant)
            return paramDef.Constant;
        
        // Case 2: DefaultParameterValueAttribute
        var defaultValueAttr = paramDef.CustomAttributes
            .FirstOrDefault(a => a.TypeFullName == "System.Runtime.InteropServices.DefaultParameterValueAttribute");
            
        if (defaultValueAttr != null && defaultValueAttr.ConstructorArguments.Count > 0)
        {
            return defaultValueAttr.ConstructorArguments[0].Value;
        }
        
        // Case 3: params array - default is empty array
        if (paramDef.CustomAttributes.Any(a => a.TypeFullName == "System.ParamArrayAttribute"))
        {
            return Array.CreateInstance(typeof(object), 0);
        }
        
        return null;
    }
    
    private string GetMethodDescription(MethodDef method)
    {
        var parameters = string.Join(", ", 
            method.Parameters
                .Where(p => !p.IsHiddenThisParameter)
                .Select(p => $"{p.Type.TypeName} {p.Name}"));
            
        return $"{method.Name}({parameters}) : {method.ReturnType.TypeName}";
    }
    
    /// <summary>
    /// Converts dnlib TypeSig to System.Type.
    /// </summary>
    private Type ConvertDnlibType(TypeSig typeSig)
    {
        if (typeSig == null)
            return typeof(void);
            
        switch (typeSig.ElementType)
        {
            case dnlib.DotNet.ElementType.Void:
                return typeof(void);
            case dnlib.DotNet.ElementType.Boolean:
                return typeof(bool);
            case dnlib.DotNet.ElementType.Char:
                return typeof(char);
            case dnlib.DotNet.ElementType.I1:
                return typeof(sbyte);
            case dnlib.DotNet.ElementType.U1:
                return typeof(byte);
            case dnlib.DotNet.ElementType.I2:
                return typeof(short);
            case dnlib.DotNet.ElementType.U2:
                return typeof(ushort);
            case dnlib.DotNet.ElementType.I4:
                return typeof(int);
            case dnlib.DotNet.ElementType.U4:
                return typeof(uint);
            case dnlib.DotNet.ElementType.I8:
                return typeof(long);
            case dnlib.DotNet.ElementType.U8:
                return typeof(ulong);
            case dnlib.DotNet.ElementType.R4:
                return typeof(float);
            case dnlib.DotNet.ElementType.R8:
                return typeof(double);
            case dnlib.DotNet.ElementType.String:
                return typeof(string);
            case dnlib.DotNet.ElementType.Object:
                return typeof(object);
                
            case dnlib.DotNet.ElementType.SZArray:
                var arrayType = typeSig.Next;
                if (arrayType != null)
                {
                    var elementType = ConvertDnlibType(arrayType);
                    return elementType.MakeArrayType();
                }
                return typeof(Array);
                
            default:
                try
                {
                    var fullName = typeSig.FullName;
                    var type = Type.GetType(fullName);
                    if (type != null)
                        return type;
                }
                catch { }
                
                return typeof(object);
        }
    }
    
    /// <summary>
    /// Builds JSON Schema for a parameter type with recursive property reflection.
    /// Gemini-compatible format with full type information.
    /// </summary>
    public Dictionary<string, object> BuildParameterSchema(TypeSig typeSig, ModuleDef module, int depth = 0)
    {
        // Prevent infinite recursion and circular references
        if (depth > 3)
        {
            return new Dictionary<string, object>
            {
                { "type", "OBJECT" },
                { "description", "Max depth reached" }
            };
        }
        
        if (typeSig == null)
        {
            return new Dictionary<string, object> { { "type", "NULL" } };
        }
        
        var fullName = typeSig.FullName;
        
        // Check if it's a primitive type
        if (JsonSchemaTypeMap.TryGetValue(fullName, out var jsonType))
        {
            var schema = new Dictionary<string, object> { { "type", jsonType } };
            
            // Add C# display name for UI
            if (CSharpDisplayTypeMap.TryGetValue(jsonType, out var csharpType))
            {
                schema["typeName"] = csharpType;
            }
            
            return schema;
        }
        
        // Check if it's an array/list
        if (typeSig.IsArray || typeSig.IsSZArray)
        {
            var elementType = typeSig.Next;
            var elemSchema = BuildParameterSchema(elementType, module, depth + 1);
            
            return new Dictionary<string, object>
            {
                { "type", "ARRAY" },
                { "items", elemSchema },
                { "typeName", $"List<{GetSimpleTypeName(elementType)}>" }
            };
        }
        
        // Check for generic types (List<T>, Dictionary<K,V>, etc.)
        if (typeSig is GenericInstSig genericInst)
        {
            var genericName = genericInst.GenericType?.TypeDefOrRef?.Name ?? "Generic";
            
            // Handle List<T>
            if (genericName.StartsWith("List") || genericName.StartsWith("IEnumerable"))
            {
                if (genericInst.GenericArguments.Count > 0)
                {
                    var elemType = genericInst.GenericArguments[0];
                    var elemSchema = BuildParameterSchema(elemType, module, depth + 1);
                    
                    return new Dictionary<string, object>
                    {
                        { "type", "ARRAY" },
                        { "items", elemSchema },
                        { "typeName", $"List<{GetSimpleTypeName(elemType)}>" }
                    };
                }
            }
        }
        
        // Complex type (class/interface) - reflect properties
        var typeDef = typeSig.TryGetTypeDef();
        if (typeDef != null && !typeDef.IsEnum)
        {
            var schema = new Dictionary<string, object>
            {
                { "type", "OBJECT" },
                { "typeName", typeDef.Name }
            };
            
            // Reflect public properties
            var properties = new Dictionary<string, object>();
            var requiredProps = new List<string>();
            
            foreach (var prop in typeDef.Properties.Where(p => p.GetMethod?.IsPublic == true))
            {
                try
                {
                    var propSchema = BuildParameterSchema(prop.PropertySig?.RetType, module, depth + 1);
                    properties[prop.Name] = propSchema;
                    
                    // Non-nullable value types are required
                    if (prop.PropertySig?.RetType?.IsValueType == true && 
                        !prop.PropertySig.RetType.FullName.StartsWith("System.Nullable"))
                    {
                        requiredProps.Add(prop.Name);
                    }
                }
                catch
                {
                    // Skip problematic properties
                }
            }
            
            if (properties.Count > 0)
            {
                schema["properties"] = properties;
            }
            
            if (requiredProps.Count > 0)
            {
                schema["required"] = requiredProps.ToArray();
            }
            
            return schema;
        }
        
        // Fallback for unknown types
        return new Dictionary<string, object>
        {
            { "type", "OBJECT" },
            { "typeName", GetSimpleTypeName(typeSig) }
        };
    }
    
    /// <summary>
    /// Gets simple type name for display (e.g., "Person" instead of "MyApp.Models.Person")
    /// </summary>
    private string GetSimpleTypeName(TypeSig typeSig)
    {
        if (typeSig == null) return "object";
        
        var fullName = typeSig.FullName;
        
        // Map known types to C# names
        if (JsonSchemaTypeMap.TryGetValue(fullName, out var jsonType))
        {
            if (CSharpDisplayTypeMap.TryGetValue(jsonType, out var csharpName))
            {
                return csharpName;
            }
        }
        
        // Return just the type name without namespace
        return typeSig.TypeName ?? "object";
    }
}

public class JavaRuntimeScanner : IRuntimeScanner
{
    public List<RailMethod> ScanBinary(string filePath, RailFactory.Core.ScanOptions? options = null)
    {
        throw new NotImplementedException("Java scanning not yet implemented");
    }
}

public class PythonRuntimeScanner : IRuntimeScanner
{
    public List<RailMethod> ScanBinary(string filePath, RailFactory.Core.ScanOptions? options = null)
    {
        throw new NotImplementedException("Python scanning not yet implemented");
    }
}



